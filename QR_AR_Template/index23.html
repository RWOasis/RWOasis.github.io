<!DOCTYPE html>
<html lang ="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">
<title>AR Seymour & Lerhn</title>
</head>
	<!-- include three.js library -->
	<script src='build/three.js'></script>
	<!-- include jsartookit -->
	<script src="build/artoolkit.min.js"></script>
	<script src="build/artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="build/threex-artoolkitsource.js"></script>
	<script src="build/threex-artoolkitcontext.js"></script>
	<script src="build/threex-arbasecontrols.js"></script>
	<script src="build/threex-armarkercontrols.js"></script>

<body style='margin : 0px;''>
	<style>
#changeImagePlay{
    z-index: 1;
    border-radius: 2px;
    border: none;
    display: flex;
    position: absolute;
    width: 70px;
    height: auto;
    bottom: 5%;
    right: 35%;
}
#container2{
	overflow: none;
    border-radius: 2px;
    border: none;
    position: absolute;
    bottom: 5%;
    right: 50%;
    left: 50%;
    width: 70px;
    height: auto;
    display: flex; 
}
#changeImageAR{
    top: 5%;
    right: 5%;
    border-radius: 2px;
    border: none;
    position: absolute;
    width: 70px;
    height: auto;
    display: none;
}
#Logo2{
    height: 40.8px;
    width: 164.8px;
  }
  #Logo3{
	position: relative;
    width: 300px;
	height: auto;
  }
  /* This keeps child nodes hidden while the element loads */
  :not(:defined) > * {
    display: none;
  }
  #arButton{
    border-radius: 4px;
    border: none;
    position: absolute;
    top: 16px;
    right: 16px
  }
#LandingContainer {
	overflow: none;
  z-index: 1;
    background-color: #FFC82E;
		color: #1c1c1c;
		text-shadow: unset;
    background-repeat: no-repeat;
    background-size: cover;
    background-position: right;
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    font-size: 24px;
    font-family: "Nunito", "Arial", sans-serif;
}

#LandingMainContent>p {
	top: 0;
  margin-top: 0.2rem;
  text-align: center;
    line-height: 100%;
    font-size: 1.2rem;
}

#LandingMainContent>h1 {
	margin-top: 1rem;
  text-align: center;
    line-height: 100%;
}

#LandingMainContent {
    overflow-x: hidden;
  text-align: center;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    text-shadow: 0.2rem 0.2rem 0.2rem rgba(0, 0, 0, 0.1);
}

.Button {
    text-decoration: none;
    padding: 1rem;
    font-size: 2rem;
    border: none;
    border-radius: 4rem;
    text-shadow: 0.5rem 0.5rem 0.5rem rgba(0, 0, 0, 0.3);
    min-width: 30%;
    cursor: pointer;
    background-color: rgb(247, 247, 247) ;
				color: #1c1c1c;
				font-size: rem;
				border: rem solid ;
				text-shadow: unset;
				box-shadow: #4d4d4d 0 0.25rem 1rem 0.2rem;
				border-radius: 3rem;
        padding: 1rem;
        font-size: 1.5rem;
}


.poweredLogo {
    margin-left: 0.5rem;
    max-width: 10rem;
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
    width: 10rem;
    height: 3rem;
}

#createdBy {
    display: flex;
    align-items: flex-end;
    text-align: center;
    font-size: 0.7rem;
    margin: 1rem 0 0 0;
    align-self: flex-start;
    flex-grow: 1;
}

#LogoAndText {
    display: flex;
    align-items: center;
}

/* Google translate */
.skiptranslate {
	color: transparent !important;
}
.skiptranslate iframe {
    display: none !important;
}
#google_translate_element {
    position: absolute;
    z-index: 1;
    left: 0;
}
#google_translate_element span {
    display: none;
}
 .goog-te-combo {
	border-radius: 2.75rem;
    padding: 0.5rem;
    color: Black;
}

@media only screen and (min-width:1024px) and (orientation:landscape) {
    #LandingMainContent {
      text-align: center;
        max-width: 27vw;
        background-color: #FFC82E;
				color: #1c1c1c;
				text-shadow: unset;
    }

    #LandingContainer {
      height: 100%;
        flex-direction: row;
        justify-content: start;
    }

    #LandingContainer {
        font-size: 16px;
        background-color: unset;
    }

    .Button {
      background-color: rgb(247, 247, 247) ;
				color: #1c1c1c;
				font-size: rem;
				border: rem solid ;
				text-shadow: unset;
				box-shadow: #4d4d4d 0 0.25rem 1rem 0.2rem;
				border-radius: 3rem;
        padding: 1rem;
        font-size: 1.5rem;
    }
}
::-webkit-scrollbar {
  background: #dba614;
}
  #checkARCompatable{
    font-size: large;
    color: red;
  }
	</style>
	<div id="LandingContainer">
		<div id="LandingMainContent">
      <div class="ClientLogo"><div id="Logo3"></div><img src="./images/logo.png" id="Logo3"></div>
			<h1></h1>

                <p id = "checkARCompatable"><b>It looks like your device might not support the full AR experience!</b> <br>You can still use this resource but if you would like to have the best experience please access it via a phone or tablet.</p>
										<p>Making learning as simple as play.</p>
                    <p>From immersive 360 virtual tours to the more traditional work-sheets.</p>
										<p>Seymour &amp; Lerhn has resources for each different type of learner.</p>
                    <p><b>SEE | HEAR | THINK | DO | MAKE</b></p>
                    <p>Seymour &amp; Lerhn AR is super easy to use, simply tap the AR icon to start the experience.</p>
										<h3>Ready?</h3>
										<p>  </p>
								<button class="Button" onclick="launchTour()">Let's go!</button>
			<div id="createdBy">
				<div id="LogoAndText">
					<span>Created by:</span>
					<div class="poweredLogo"><a href="https://www.seymourlerhn.com"><div id="Logo2"><img src="https://www.seymourlerhn.com/AR-Ready/Setup/images/logo.png" id="Logo2"></div></a></div></div>
				</div>
			</div>
		</div>
	</div>
	<div id="rotCheck">Checking Rotation...</div>
<script>
function launchTour () {
if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
  DeviceOrientationEvent.requestPermission()
  .then(permissionState => {
  if (permissionState === 'granted') {
  window.addEventListener('deviceorientation', () => {});
  }
  })
  .catch(console.error);
  } else {
  // handle regular non iOS 13+ devices
  console.log ("not iOS");
  }
  document.getElementById("LandingContainer").style.display = "none";
  //AudioOpen.play();
  //playAudio = true;
}
</script>

  <script type="module">    
  //import * as THREE from 'https://www.seymourlerhn.com/AR-Ready/Portal/node_modules/three/build/three.module.js';  import { GLTFLoader } from 'https://www.seymourlerhn.com/AR-Ready/Portal/node_modules/three/examples/jsm/loaders/GLTFLoader.js';import { DeviceOrientationControls } from 'https://www.seymourlerhn.com/AR-Ready/Portal/node_modules/three/examples/jsm/controls/DeviceOrientationControls.js';
  import * as THREE from './build/three.module.js';  import { GLTFLoader } from './build/GLTFLoader.js';import { DeviceOrientationControls } from './build/DeviceOrientationControls.js';
  var scene, camera, renderer, clock, deltaTime, totalTime;

var arToolkitSource, arToolkitContext, orientationControls, useOrientationControls = false;

var markerRoot1, ballMesh, sceneGroup, clip, clips,targetRotation;

var markerRootA,markerRootB,markerRootC,markerRootD,markerRootE;

var checkOnce = true,action, targetRotationZ;

var canPuke = true, canPollen = true, canIdle = true;

var material1, mesh1,isMobile = false,moveSpeed = 0.1;

var glbPath = "glbAssets/", glbName = "Bee.glb", mixer,hasLoaded = false;

var timer = 0, timeSet= 5000, targetPosition = new THREE.Vector3(0,-2,-20);
setInterval(function(){     
    timer += 100;
}, 100);
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
        || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
        document.getElementById("checkARCompatable").style.display = "none";
		isMobile = true;
    }
var landingPageOpen = true;
initialize();

async function initialize()
{
	scene = new THREE.Scene();
				
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );
	document.body.style.overflow = 'hidden';

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	
	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
	});

	function onResize()
	{
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		onResize()
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize()
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'images/camera_para.dat',
		detectionMode: 'mono'
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	
	markerRootA = new THREE.Group();
	scene.add(markerRootA);
	let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRootA, {
		type: 'pattern', patternUrl: "images/IdleLandQR.patt",
	});
	markerRootB = new THREE.Group();
	scene.add(markerRootB);
	let markerControls2 = new THREEx.ArMarkerControls(arToolkitContext, markerRootB, {
		type: 'pattern', patternUrl: "images/IdleLandQR.patt",
	});
	markerRootC = new THREE.Group();
	scene.add(markerRootC);
	let markerControls3 = new THREEx.ArMarkerControls(arToolkitContext, markerRootC, {
		type: 'pattern', patternUrl: "images/CollectQR.patt",
	});
	markerRootD = new THREE.Group();
	scene.add(markerRootD);
	let markerControls4 = new THREEx.ArMarkerControls(arToolkitContext, markerRootD, {
		type: 'pattern', patternUrl: "images/FlyingIdleQR.patt",
	});
	////////////////////////////////////////////////////////////
	// setup scene
	////////////////////////////////////////////////////////////
	
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	
	let loader = new THREE.TextureLoader();
		
	sceneGroup = new THREE.Group();
    markerRootB.add(sceneGroup);
	camera.add(markerRootB);

	let floorGeometry = new THREE.PlaneGeometry( 20,20 );
	let floorMaterial = new THREE.ShadowMaterial();
	floorMaterial.opacity = 0.3;
	let floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
	floorMesh.rotation.x = -Math.PI/2;
	floorMesh.receiveShadow = true;
	sceneGroup.add( floorMesh );
	
    const loader2 = new GLTFLoader().setPath( glbPath );
        loader2.load( glbName, async function ( gltf ) {
            mixer = new THREE.AnimationMixer( gltf.scene );
            ballMesh = gltf.scene;
			ballMesh.scale.set(0.5,0.5,0.5)
            clips = gltf.animations;
			console.log(clips)
        	clip = clips[2];
            action = mixer.clipAction( clip );
            if(action != ""){
                action.play();
                console.log(action);
            }
            gltf.scene;
            gltf.scenes;
            gltf.asset;
            gltf.scene.position.set(0,0,0);
	    sceneGroup.add( ballMesh );
        orientationControls = new DeviceOrientationControls( camera );
        hasLoaded = true;
		scene.add(sceneGroup);
        });



	let ambientLight = new THREE.AmbientLight( 0x666666, 7 );
    let hemiLight = new THREE.HemisphereLight(0xddeeb1, 0x080820, 4)
    let spotLight = new THREE.SpotLight(0xffa95c, 2)
	scene.add( ambientLight );scene.add( hemiLight );scene.add( spotLight );
	// let helper = new THREE.CameraHelper( light.shadow.camera );
	// sceneGroup.add( helper );
	
	// default normal of a plane is 0,0,1. Apply mesh rotation to it.
	let clipPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
		new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0) );
	renderer.clippingPlanes = [clipPlane];
	animate();
}

var doOnce = true;

function update()
{
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false ){
		arToolkitContext.update( arToolkitSource.domElement );
    }
    if(hasLoaded == true){
	if ( markerRootB.visible )
	{    
		console.log("markerRootB");  
		if(markerRootB){
		
        // camera.rotation.x = 1.6;    
		// align clipping plane to scene.
        //camera.rotation.set(0,0,0);
		var wpVector = new THREE.Vector3();
		var targetPosition2 = markerRootB.getWorldPosition(wpVector);
		console.log(targetPosition2)
		let p = parabolicPath( ballMesh.position, targetPosition2, moveSpeed );
		if (ballMesh.position.x >= targetPosition2.x - 4 && ballMesh.position.x <= targetPosition2.x + 4){
			targetRotation  = (camera.rotation.x/2 + camera.rotation.x) +1.8;
			targetRotationZ = (camera.rotation.z + camera.rotation.z/2)+1.8;
			
			if(ballMesh.rotation.x > targetRotation){
				ballMesh.rotation.x -= 0.03;
			}
			if(ballMesh.rotation.x < targetRotation){
				ballMesh.rotation.x += 0.03;
			}

        }
		ballMesh.position.copy( p );
		if (ballMesh.position.x >= targetPosition2.x - 0.34 && ballMesh.position.x <= targetPosition2.x + 0.34 && ballMesh.position.z >= targetPosition2.z - 0.34 && ballMesh.position.z <= targetPosition2.z + 0.34){
			if(clip != clips[4]){
				moveSpeed = 1;
					mixer = new THREE.AnimationMixer( ballMesh );
					clip = clips[4];
            		action = mixer.clipAction( clip );
            		if(action != ""){
                		action.play();
            		}
				}
		}
	}
        useOrientationControls = true;
	}
	if ( markerRootC.visible ){    
			if(canPuke == true){
				var wpVector = new THREE.Vector3();
				var targetPosition2 = markerRootC.getWorldPosition(wpVector);  
				let p = parabolicPath( ballMesh.position, targetPosition2, moveSpeed );
			if (ballMesh.position.x >= targetPosition2.x - 4 && ballMesh.position.x <= targetPosition2.x + 4){
			targetRotation  = (camera.rotation.x/2 + camera.rotation.x) +1.8;
			targetRotationZ = (camera.rotation.z + camera.rotation.z/2)+1.8;
			
			if(ballMesh.rotation.x > targetRotation){
				ballMesh.rotation.x -= 0.03;
			}
			if(ballMesh.rotation.x < targetRotation){
				ballMesh.rotation.x += 0.03;
			}
		}
		ballMesh.position.copy( p );
		console.log(ballMesh.position.x - targetPosition2.x);
		if (ballMesh.position.x >= targetPosition2.x - 0.7 && ballMesh.position.x <= targetPosition2.x + 0.7){
			if(clip != clips[0]){
				moveSpeed = 1;
					mixer = new THREE.AnimationMixer( ballMesh );
					clip = clips[0];
            		action = mixer.clipAction( clip );
            		if(action != ""){
                		action.play();
            		}
				}
			}
		}
		}
		if ( markerRootD.visible ){    
			console.log("markerRootD");  
			if(canPuke == false){
				var wpVector = new THREE.Vector3();
				var targetPosition2 = markerRootD.getWorldPosition(wpVector);
				let p = parabolicPath( ballMesh.position, targetPosition2, moveSpeed );
			if (ballMesh.position.x >= targetPosition2.x - 4 && ballMesh.position.x <= targetPosition2.x + 4){
			targetRotation  = (camera.rotation.x/2 + camera.rotation.x) +1.8;
			targetRotationZ = (camera.rotation.z + camera.rotation.z/2)+1.8;
			
			if(ballMesh.rotation.x > targetRotation){
				ballMesh.rotation.x -= 0.03;
			}
			if(ballMesh.rotation.x < targetRotation){
				ballMesh.rotation.x += 0.03;
			}
		}
		ballMesh.position.copy( p );
		if (ballMesh.position.x >= targetPosition2.x - 0.34 && ballMesh.position.x <= targetPosition2.x + 0.34 && ballMesh.position.z >= targetPosition2.z - 0.34 && ballMesh.position.z <= targetPosition2.z + 0.34){
			if(clip != clips[3]){
				moveSpeed = 1;
					mixer = new THREE.AnimationMixer( ballMesh );
					clip = clips[3];
            		action = mixer.clipAction( clip );
            		if(action != ""){
                		action.play();
            		}
				}
			}
		}
		}else{
        if(timer >= timeSet){
            timeSet = Math.floor(Math.random() * (10000 - 1000) + 1000);
            timer = 0;
            targetPosition = new THREE.Vector3(Math.floor(Math.random() * (4 - 4) + -4),Math.floor(Math.random() * (1 - -1) + -1),Math.floor(Math.random() * (-5 - -30) + -30));
        }
		targetRotation = 0;
		targetRotationZ = 0;
        let p = parabolicPath( ballMesh.position, targetPosition, 0.02);
        ballMesh.position.copy( p );
        useOrientationControls = true;
			if(clip != clips[3]){
				moveSpeed = 0.05;
					mixer = new THREE.AnimationMixer( ballMesh );
					clip = clips[3];
            		action = mixer.clipAction( clip );
					doOnce = true;
            		if(action != ""){
                		action.play();
            		}
				}
				
			if(ballMesh.rotation.x > targetRotation){
				ballMesh.rotation.x -= 0.03;
			}
			if(ballMesh.rotation.x < targetRotation){
				ballMesh.rotation.x += 0.03;
			}
    	}
    }
}

// create a function p() that passes through the points (0,p0), (1,p1), (2,p2) 
//  and evaluate that function at time t.
function parabolaEvaluate(p0, p1, p2, t)
{
	return ( 0.5*(p0 - 2*p1 + p2) )*t*t + ( -0.5*(3*p0 - 4*p1 + p2) )*t + ( p0 );
}

function parabolicPath( pointStart, pointEnd, time )
{
	let pointMiddle = new THREE.Vector3().addVectors( pointStart, pointEnd ).multiplyScalar(0.5).add( new THREE.Vector3(0,0.3,0) );
	return new THREE.Vector3(
		parabolaEvaluate( pointStart.x, pointMiddle.x, pointEnd.x, time ),
		parabolaEvaluate( pointStart.y, pointMiddle.y, pointEnd.y, time ),
		parabolaEvaluate( pointStart.z, pointMiddle.z, pointEnd.z, time )
	);	
}

function render()
{
	renderer.render( scene, camera );
}

function animate()
{
    if(useOrientationControls == true){
		if(isMobile == true){
			orientationControls.update();
		}
    }
	requestAnimationFrame(animate);
	deltaTime = clock.getDelta();
    if(hasLoaded == true){
        mixer.update( deltaTime )
    }
	totalTime += deltaTime;
	update();
	render();
}
camera.rotation.set(0,0,0);

  </script>
</body>
</html>